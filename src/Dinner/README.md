# 模拟五个哲学家进餐问题

## 设计内容 
   5个哲学家同坐在一张圆桌旁，每个人的面前摆放着碗，碗的两旁各摆放着一只筷子。
假设哲学家的生活除了吃饭就是思考问题（这是一种抽象，即对该问题而言其他活动都无关
紧要），而吃饭的时候需要左手拿一只筷子，右手拿一只筷子，然后开始进餐。吃完后又将
筷子放回原处，继续思考问题。设计一个程序，能够显示当前各哲学家的状态和桌上餐具的
使用情况，并能无死锁的推算出下一状态各哲学家的状态和桌上餐具的使用情况。即设计一
个能安排哲学家正常生活的程序。为哲学家设计 3 种状态，即“等待”“进餐”“思考”。每
个哲学家重复进行“等待”->“进餐”->“思考”的行动循环。
    （1）“等待”->“进餐”：只有一个哲学家处于等待进餐状态，且左右手两边的筷子都处
于“空闲”状态时，可以发生这种状态改变。此状态改变发生后，哲学家拿起左右手两边的
筷子。
    （2）“进餐”->“思考”：此状态改变发生后，哲学家放下左右手上的筷子。筷子状态由
“使用中”转变为“空闲”
    （3）“思考”->“等待”：哲学家思考结束后，无条件转入等待状态。
  
##算法原理

至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出
他所使用过的两支筷子，从而可使更多的哲学家进餐。将 room 作为信号量，只允许 4 个哲
学家同时进入餐厅就餐，这样就能保证至少有一个哲学家可以就餐，而申请进入餐厅的哲学
家进入 room 的等待队列。根据 FIFO 的原则，总会进入就餐。因此不会出现饿死和死锁的现
象。伪码：
````
Semaphore chopstick[5]={1,1,1,1,1};
Semaphore room=4;
void philosopher(int i) {
    while(true) {
        Think();
        Wait(room); //请求进入房间进餐
        wait(chopstick[i]); //请求左手边的筷子
        wait(chopstick[(i+1)]%5); //请求右手边的筷子
        eat();
        signal(chopstick[(i+1)]%5); //释放右手边的筷子
        singal(chopstick[i]); // 释放右手边的筷子
        singal(room);
    }
}
````
## 结果展示

